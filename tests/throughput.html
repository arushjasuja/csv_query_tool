<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Throughput Tests - CSV Query Tool</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 900px;
      margin: 40px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      color: #2c3e50;
      margin-bottom: 10px;
    }
    .subtitle {
      color: #7f8c8d;
      margin-bottom: 30px;
    }
    button {
      background: #3498db;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      font-size: 16px;
      cursor: pointer;
    }
    button:hover {
      background: #2980b9;
    }
    button:disabled {
      background: #95a5a6;
      cursor: not-allowed;
    }
    #results {
      margin-top: 30px;
      white-space: pre-wrap;
      font-family: monospace;
      background: #f8f9fa;
      padding: 20px;
      border-radius: 4px;
      line-height: 1.6;
    }
    .pass {
      color: #27ae60;
      font-weight: bold;
    }
    .fail {
      color: #e74c3c;
      font-weight: bold;
    }
    #status {
      margin: 20px 0;
      padding: 12px;
      border-radius: 4px;
    }
    #status.loading {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Throughput Tests</h1>
    <p class="subtitle">Query throughput measurements (queries per second)</p>
    
    <button id="run-tests">Run Throughput Tests</button>
    
    <div id="status"></div>
    <div id="results"></div>
  </div>

  <script type="module">
    import * as duckdb from 'https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.30.0/+esm';

    let db = null;
    let conn = null;

    async function initDuckDB() {
      const JSDELIVR_BUNDLES = duckdb.getJsDelivrBundles();
      const bundle = await duckdb.selectBundle(JSDELIVR_BUNDLES);
      
      const worker_url = URL.createObjectURL(
        new Blob([`importScripts("${bundle.mainWorker}");`], {type: 'text/javascript'})
      );
      
      const worker = new Worker(worker_url);
      const logger = new duckdb.ConsoleLogger();
      db = new duckdb.AsyncDuckDB(logger, worker);
      await db.instantiate(bundle.mainModule, bundle.pthreadWorker);
      URL.revokeObjectURL(worker_url);
      
      conn = await db.connect();
      await conn.query("PRAGMA memory_limit='4GB'");
    }

    function generateCSV(rows) {
      const columns = ['id', 'name', 'department', 'salary', 'hire_date'];
      const departments = ['Engineering', 'Sales', 'Marketing', 'HR'];
      
      let csv = columns.join(',') + '\n';
      
      for (let i = 0; i < rows; i++) {
        const row = [
          i + 1,
          `Employee${i}`,
          departments[i % departments.length],
          Math.floor(50000 + Math.random() * 100000),
          `2020-${String(Math.floor(Math.random() * 12) + 1).padStart(2, '0')}-01`
        ];
        csv += row.join(',') + '\n';
      }
      
      return csv;
    }

    async function loadCSV(csvData) {
      const blob = new Blob([csvData], { type: 'text/csv' });
      const file = new File([blob], 'test.csv', { type: 'text/csv' });
      
      await db.registerFileHandle('test.csv', file, duckdb.DuckDBDataProtocol.BROWSER_FILEREADER, true);
      
      try {
        await conn.query('DROP TABLE IF EXISTS tablename');
      } catch (e) {}
      
      await conn.query("CREATE TABLE tablename AS SELECT * FROM read_csv_auto('test.csv')");
    }

    async function executeQuery(query) {
      await conn.query(query);
    }

    async function runThroughputTest(test) {
      const startTime = performance.now();
      
      if (test.concurrency === 1 || !test.concurrency) {
        for (let i = 0; i < test.queryCount; i++) {
          await executeQuery(test.query);
        }
      } else {
        const batches = Math.ceil(test.queryCount / test.concurrency);
        let remaining = test.queryCount;
        
        for (let i = 0; i < batches; i++) {
          const batchSize = Math.min(test.concurrency, remaining);
          const promises = [];
          
          for (let j = 0; j < batchSize; j++) {
            promises.push(executeQuery(test.query));
          }
          
          await Promise.all(promises);
          remaining -= batchSize;
        }
      }
      
      const totalSeconds = (performance.now() - startTime) / 1000;
      const throughput = test.queryCount / totalSeconds;
      
      return {
        throughput: throughput.toFixed(2),
        totalTime: totalSeconds.toFixed(2),
        passed: throughput >= test.target
      };
    }

    async function runAllTests() {
      const resultsDiv = document.getElementById('results');
      const statusDiv = document.getElementById('status');
      const runButton = document.getElementById('run-tests');
      
      runButton.disabled = true;
      statusDiv.className = 'loading';
      statusDiv.textContent = 'Generating test data (100MB)...';
      
      const csvData = generateCSV(1000000);
      const sizeBytes = new Blob([csvData]).size;
      
      statusDiv.textContent = 'Loading CSV into DuckDB...';
      await loadCSV(csvData);
      
      const tests = [
        {
          name: 'Sequential Simple Queries',
          queryCount: 50,
          concurrency: 1,
          query: 'SELECT COUNT(*) FROM tablename',
          target: 10
        },
        {
          name: 'Sequential Aggregations',
          queryCount: 30,
          concurrency: 1,
          query: 'SELECT department, AVG(salary) FROM tablename GROUP BY department',
          target: 5
        },
        {
          name: 'Concurrent Simple Queries',
          queryCount: 100,
          concurrency: 10,
          query: 'SELECT AVG(salary) FROM tablename',
          target: 20
        },
        {
          name: 'Concurrent Filtered Queries',
          queryCount: 60,
          concurrency: 6,
          query: 'SELECT * FROM tablename WHERE salary > 80000 LIMIT 100',
          target: 15
        }
      ];
      
      let output = '\nThroughput Test Results\n';
      output += '='.repeat(50) + '\n';
      output += `File Size: ${(sizeBytes / 1024 / 1024).toFixed(2)} MB (1M rows)\n\n`;
      
      let allPassed = true;
      
      for (const test of tests) {
        statusDiv.textContent = `Running: ${test.name}...`;
        const result = await runThroughputTest(test);
        
        const status = result.passed ? '✓' : '✗';
        const statusClass = result.passed ? 'pass' : 'fail';
        allPassed = allPassed && result.passed;
        
        output += `${test.name}: ${result.throughput} q/s <span class="${statusClass}">${status}</span> (target: ${test.target} q/s)\n`;
        output += `  Total: ${result.totalTime}s for ${test.queryCount} queries\n`;
        if (test.concurrency > 1) {
          output += `  Concurrency: ${test.concurrency}\n`;
        }
        output += '\n';
      }
      
      output += allPassed ? '<span class="pass">All tests passed!</span>' : '<span class="fail">Some tests failed</span>';
      output += '\n';
      
      resultsDiv.innerHTML = output;
      statusDiv.className = '';
      statusDiv.textContent = '';
      runButton.disabled = false;
    }

    document.addEventListener('DOMContentLoaded', async () => {
      await initDuckDB();
      
      document.getElementById('run-tests').addEventListener('click', runAllTests);
    });
  </script>
</body>
</html>
